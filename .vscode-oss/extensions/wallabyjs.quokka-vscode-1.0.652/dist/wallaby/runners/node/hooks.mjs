import{readdirSync}from"node:fs";import{join,dirname}from"node:path";import{existsSync}from"node:fs";import{pathToFileURL}from"url";import*as module from"node:module";import{MessageChannel}from"node:worker_threads";import*as os from"node:os";function findFileUpward(o){const e=os.homedir();try{let r=process.cwd();for(;r;){const t=join(r,o);if(existsSync(t))return t;const n=dirname(r);if(n===r||n===e)break;r=n}return null}catch(o){return null}}const pnpLoaderFilename=findFileUpward(".pnp.loader.mjs"),pnpLoaderExists=!!pnpLoaderFilename;let pnpLoader,customConditions;async function getPnpLoader(){return pnpLoader||(pnpLoader=await import(pnpLoaderFilename),pnpLoader)}function convertToPosix(o){return"win32"===process.platform?o.replace(/\\/g,"/"):o}export function setExternalLoad(o){global.$_$_externalLoad=o}export function setExternalResolve(o){global.$_$_externalResolve=o}export function findMatchingFiles(o,e,r,t){const n=[];for(const r of readdirSync(o))r.match(e)&&n.push(convertToPosix(join(o,r)));if(r&&0===n.length)throw new Error(`File '${e}' is not found in '${o}'`);if(t&&n.length>1)throw new Error(`More than one file '${e}' were found in '${o}'`);return n}export function patchFile(o,e){const r=pathToFileURL(o).toString();global.$_$esmHooksPort?global.$_$esmHooksPort.postMessage({type:"patch",url:r,patches:e}):addPatch(r,e)}export function getErrorsAndWarnings(){const[o]=process.versions.node.split(".").map((o=>parseInt(o,10)));return o>=22?{warnings:global.$_$_esm_warnings||[],errors:global.$_$_esm_errors||[]}:global.$_$esmHooksPort?new Promise(((o,e)=>{const r=e=>{const{type:t,warnings:n,errors:a}=e.data;if("errorsAndWarnings"===t)o({warnings:n,errors:a}),global.$_$esmHooksPort.removeEventListener("message",r)};global.$_$esmHooksPort.addEventListener("message",r),global.$_$esmHooksPort.postMessage({type:"getWarnings"})})):{warnings:global.$_$_esm_warnings||[],errors:global.$_$_esm_errors||[]}}export async function resolve(o,e,r){if(customConditions&&(e.conditions=[...customConditions,...e.conditions||[]]),global.$_$_externalResolve)try{const t=await global.$_$_externalResolve(o,e,r);if(t)return t}catch(o){}if(!pnpLoaderExists)return await r(o,e,r);try{return await r(o,e,r)}catch(t){const n=(await getPnpLoader()).resolve;return await n(o,e,r)}}export function applyReplacements(o,e,r){let t="";return e.reduce(((e,r)=>(r.forEach(((n,a)=>{if(!t&&-1===e.indexOf(n.from)&&!n.optional)if(n.key){if(!r.find(((o,r)=>r!==a&&o.key===n.key&&-1!==e.indexOf(o.from)))){const e=`Initialization: Wallaby is not compatible with current version of Vitest.\nCould not find ${n.key} in entry point for file ${o.toString()}.`;n.warn?global.$_$_esm_warnings.push(e):(global.$_$_esm_errors.push(e),t=e)}}else{const e=`Initialization: Wallaby is not compatible with current version of Vitest.\nCould not find ${n.from} in entry point for file ${o.toString()}.`;n.warn?global.$_$_esm_warnings.push(e):(global.$_$_esm_errors.push(e),t=e)}})),t?`throw new Error(${JSON.stringify(t)});`:r.reduce(((o,e)=>o.replace(e.from,e.to)),e))),r)}async function loadAndPatch(o,e,r,t){const n=await t(o,e,r);return global.$_$_esm_patches&&global.$_$_esm_patches[o]&&n.source&&(n.source=applyReplacements(o,global.$_$_esm_patches[o],n.source.toString())),n}export async function load(o,e,r){if(global.$_$_externalLoad)try{return await loadAndPatch(o,e,r,global.$_$_externalLoad)}catch(o){}if(!pnpLoaderExists)return await loadAndPatch(o,e,r,r);try{const t=await loadAndPatch(o,e,r,r);if("builtin"!==t.format&&!t.source){const t=(await getPnpLoader()).load;return await loadAndPatch(o,e,r,t)}return t}catch(t){try{const t=(await getPnpLoader()).load;return await loadAndPatch(o,e,r,t)}catch(o){throw t}}}function addPatch(o,e){global.$_$_esm_patches=global.$_$_esm_patches||{},global.$_$_esm_warnings=[],global.$_$_esm_errors=[],global.$_$_esm_patches[o]?global.$_$_esm_patches[o].push(e):global.$_$_esm_patches[o]=[e]}export function globalPreload(o){const e=[];for(let o=0;o<process.execArgv.length;o++){const r=process.execArgv[o];("--conditions"===r||"-C"===r)&&o+1<process.execArgv.length&&e.push(process.execArgv[o+1])}customConditions=e.length?e:void 0;const[r,t]=process.versions.node.split(".").map((o=>parseInt(o,10)));if(r<18||18===r&&t<19)return;if(!o||!o.port)throw new Error("Unexpected globalPreload argument value");const n=o.port;return n.onmessage=o=>{const{type:e,url:r,patches:t}=o.data;switch(e){case"patch":addPatch(r,t);break;case"getWarnings":n.postMessage({type:"errorsAndWarnings",warnings:global.$_$_esm_warnings,errors:global.$_$_esm_errors})}},"    global.$_$esmHooksPort = port;\n  "}export async function initialize(o){globalPreload(o)}export async function registerHook(){const[o,e]=process.versions.node.split(".").map((o=>parseInt(o,10)));if(o<18||18===o&&e<19||20===o&&e<6)return;const{port1:r,port2:t}=new MessageChannel;global.$_$esmHooksPort=r,await module.register(import.meta.url,{parentURL:import.meta.url,data:{number:1,port:t},transferList:[t]})}